------------------------------------------------------------------
协程消息系统
语言：C/C++
截止日期：3 周
复杂度：平均约 10 小时，500 行代码。
------------------------------------------------------------------

请阅读完整描述。它不仅包含任务说明，还包含提示、一些学习资料、时间估算、规则，并指出常见错误，以及建议的附加任务。

-------------------------- 描述 ---------------------------

有一个名为 bus 的消息对象，类似于主板上的总线。该总线允许打开通道，用于发送简单的消息。

需要实现这个支持协程的 bus 消息对象。

协程，也称为协同程序、轻量级线程、虚拟线程、绿色线程或纤程，是程序流程的一个单元。它运行线性代码并拥有栈，与普通线程相同，但它不能由内核调度。相反，协程是用户空间对象，完全由用户空间进行调度。最简单的设置是一个线程内部包含多个协程，并可以轮流运行它们。

协程本身已经实现，bus 的概念也非常简单。主要的挑战是使 bus 与这些协程兼容。

例如，bus 通道有大小限制。当协程尝试向通道发送消息，但通道已满时，协程必须暂停，直到通道中有可用空间。

测试文件位于 test.cpp。实现模板位于 corobus.h 和 corobus.cpp。协程 API 位于 libcoro.h。其他文件无需修改。除非您想查看测试或协程的内部实现。例如，libcoro_test.cpp 仅用于测试协程引擎。任务不需要更改该引擎中的任何内容。只需使用其 API 即可。

----------------------------- 规则 ------------------------------

- 必须严格遵循 corobus.h 注释中解释的每个函数的行为。

- 提供的所有测试都必须通过。 - 代码应使用以下编译器标志成功编译：
`-Wextra -Werror -Wall -Wno-gnu-folding-constant`。

-------------------------- 限制 --------------------------

- 不允许使用全局变量（已存在的除外）。

- 不允许出现内存泄漏。您可以使用 cmake 选项 `ENABLE_LEAK_CHECKS` 进行检查。Valgrind 或 ASAN 显示零泄漏报告并不足够——它们经常会遗漏一些泄漏。

- 不能修改 test.cpp、libcoro.cpp、libcoro.h 文件。

-------------------------- 放宽条件 ---------------------------

- 您可以假设 new/delete/malloc()/realloc()/calloc() 等内存分配函数永远不会失败。

- 您可以使用 utils/rlist.h 中定义的侵入式列表容器。

----------------------- 可能的解决方案 -----------------------

- 15 分：通过所有基本测试。

- +5 分：实现“广播”功能。要启用广播测试，您需要在 corobus.h 中将宏 NEED_BROADCAST 定义为 1。测试必须通过。请参阅 corobus.h 头文件，了解广播函数的功能。

- +5 分：批量发送/接收。要启用相应的测试，您需要在 corobus.h 中将宏 NEED_BATCH 定义为 1。测试必须通过。请参阅 corobus.h 头文件，了解批量函数的功能。

额外的 +5 分选项彼此独立。也就是说，您可以选择不做，或者只做其中一个，或者两个都做，总共可以获得 +10 分。

--------------------------- 复杂度 ---------------------------

完成此任务所需的时间和精力。这些数字可以帮助您进行计划。这些数据是根据至少获得最低分数的完成任务的人员收集的。

- 代码行数：350-700 行，平均 500 行。

- 所需总时间：
* 高级水平：约 6 小时。 
* 平均水平：约 10 小时。 
* 遇到困难：约 19 小时或更长时间。

- 时间分配：
* 实际编码：约 2-4 小时。 * 剩下的就是阅读代码、理解任务和协程、进行调试。

--------------------------- 如何运行 ---------------------------

该任务使用 CMake 进行编译。以下是使用方法：

- 进入任务文件夹，确保你的路径是 <...>/sysprog/1/。
- 创建一个 build 文件夹并进入该文件夹：
mkdir build
cd build
- 配置项目：
cmake ..
- 编译：
make
- 现在你可以运行测试：
./test

CMake 提供了一些选项。每个选项（例如 SOME_OPTION）都可以使用以下语法设置为特定值：
cmake -DSOME_OPTION=value ..

此任务可用的选项如下：

- ENABLE_LEAK_CHECKS - 使用 heap_help 工具进行构建，以检查是否存在内存泄漏或堆使用错误。 
- 0 = 禁用。默认值。 
- 1 = 启用

- ENABLE_GLOB_SEARCH - 构建文件夹中的所有 C 和 C++ 源文件。这主要在你创建了更多文件时需要用到。

你自己看，不用把它们全部列出来。 
- 0 = 禁用。默认值。 
- 1 = 启用

- CMAKE_BUILD_TYPE。 
- Release = 启用编译器优化。速度更快，但不太方便进行交互式调试。 
- Debug = 禁用编译器优化。速度较慢，但​​适合进行交互式调试。

----------------------- 建议和提示 ------------------------

- 尝试查看 libcoro_test.cpp 和 test.cpp，了解协程的使用方法。尝试运行 libcoro_test.cpp，添加一些打印语句，使用调试器，看看它是如何工作的。

- 阅读 libcoro.h，了解可用的 API。看看哪些 API 可以用于你的解决方案。

- 如果你需要更多关于“协程”概念的信息，可以尝试询问 ChatGPT 或其他 AI。

- 任务中的协程与 Go 语言中的 goroutine 非常相似。“corobus”对象与 Go 语言的通道非常相似。

- 一旦你理解了 libcoro 协程，就可以尝试设计你的解决方案。先在脑海中构思，然后用文字写下来。在你知道要编写什么代码之前，不要开始编写代码。先思考，后编码。

- 首先实现 'try_send'、'try_recv' 和其他 'try' 函数。它们不会阻塞当前协程，因此实现起来非常简单。然后尝试通过 'try_send' 实现 'send'，通过 'try_recv' 实现 'recv'，依此类推。

关于协程的进一步说明。如果你难以理解它们是什么，可以尝试换个角度——把它们想象成“可恢复的函数”。

每个协程都有一个函数作为其主体（在 coro_new() 中指定）。这个函数可以调用其他函数，并且通常像其他代码一样工作。但是，这个可恢复的函数可以暂停。当你调用 coro_yield() 时就会发生这种情况。然后可以通过调用 coro_wakeup() 来恢复它。例如，可以启动协程 1，它执行一些工作，然后暂停；接着创建协程 2 并运行，然后暂停；之后协程 1 继续工作直到暂停，以此类推。

协程就像对象一样，实际上就是结构体。一个进程、一个线程可以拥有多个协程。作为协程的使用者，您可以选择何时恢复或暂停这些函数对象。

请记住，这一切都发生在单个线程中。此任务中的协程轮流执行，它们并非真正并行运行。它们是并发执行，但不是并行执行。因此，这里不需要互斥锁或任何其他同步方法。