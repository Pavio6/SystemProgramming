------------------------------------------------------------------
Shell。
语言：C/C++
截止时间：3 周。
复杂度：平均约 15 小时，约 350 行代码。
------------------------------------------------------------------

请完整阅读说明。它不仅包含任务本身，还包含提示和一些教学材料、时间评估、规则、
指出常见错误，并建议加分任务。

-------------------------- 任务描述 --------------------------

你需要实现一个简化版的命令行控制台。它应能接收如下形式的输入：

    > command_name param1 param2 ...

并通过调用带给定参数的 `command_name` 来执行。基本上就是一个终端。

文件 `parser.h` 和 `parser.cpp` 已经为你实现了一个命令解析器。
你可以自由使用这个解析器，或自己实现一个，或使用其他解析器。

文件 `parser_test.cpp` 可以忽略。它只是用于测试解析器本身。
你不需要提交它，除非你只是想看看它如何工作的示例。

你唯一需要关注的文件是 `solution.cpp`，其中包含了解题模板。
但如有需要，你也可以添加更多文件。

你的终端行为必须与 Bash 完全一致，至少在本任务和测试要求的方面。

----------------------------- 规则 -----------------------------

- 程序必须正确处理带引号的字符串，即使其中包含空格。

- 需要处理注释（通过截断/去除）。

- 控制台需要支持使用 `|` 表示的管道，以及使用 `>` 和 `>>` 的输出重定向。

- 程序输出应与真实终端（如 `/bin/bash`）的输出完全一致。

- 需要使用函数 `pipe()`、`dup/dup2()`、`fork()`、`wait()`、
  `open()`、`close()`，以及至少一个 `execl/execle/execlp/execv/execvp/execvP()`。

- `cd` 命令需要你自己实现，而不是通过 `exec` 系列函数，
  因为它会改变终端自身的当前工作目录。幸运的是，使用 C 函数 `chdir()` 很容易实现。

- `exit` 命令也像 `cd` 一样特殊，因为它作用于终端本身。
  它必须手动实现。但要注意：只有在“输出到终端本身”这一特殊条件下才应退出。
  如果它被重定向，则不应结束终端。
  例如，`exit`、`exit 123 && echo test`、`exit 456 || echo test`
  都会终止终端。但 `exit | echo 100` 不会终止。
  如有疑问，请用 `/bin/bash` 测试行为，你的终端必须与之相同。

- 控制台应支持在 `/bin/bash` 可以解析的情况下不加空格的 token，例如：
  `echo "4">file`（等同于 `echo "4" > file`），或
  `echo 100|grep 100`（等同于 `echo 100 | grep 100`）。

- 若某些行为不清楚，应在真实终端（如 `/bin/bash`）中测试并复现其行为。

- 代码必须能在以下编译选项下成功构建：
  `-Wextra -Werror -Wall -Wno-gnu-folding-constant`。

-------------------------- 限制 --------------------------

- 禁止全局变量（已存在的除外）。

- 禁止内存泄漏。可使用 cmake 选项 `ENABLE_LEAK_CHECKS` 检测。
  仅依赖 Valgrind 或 ASAN 的 “0 报告” 不足够——它们经常漏报。

- 命令行输入长度不受限制，因此不能读入固定大小的缓冲区。
  但每一行显然可以放入主存。

- 禁止使用 `system()`、`popen()` 等函数，或其他访问现成 shell 功能的方式。

-------------------------- 放宽要求 --------------------------

- 不需要支持对特定输出流的重定向，如 `1>`、`2>`、`$>`、`1>>` 等。
  （普通的 `>` 和 `>>` 仍然需要。）

- 不需要支持多个重定向，如 `cmd > file1 > file2` 或 `cmd > file1 file2`。

- `cd` 命令不需要支持 `~` 或 `-` 路径。

- 可以使用 `parser.h` 和 `parser.cpp` 中已有的解析器，其用法在 `solution.cpp` 中有示例。

- 可以假设内存分配函数（如 `new/delete/malloc()/realloc()/calloc()`）永远不会失败。

----------------------- 可能的得分方案 -----------------------

- 15 分：完成上述所有内容。

- +5 分：支持 `&`。

- +5 分：支持操作符 `&&` 和 `||`。注意该加分项相对较难实现。

两个 +5 的附加选项彼此独立。你可以不做，或只做其中一个，或两个都做（+10）。

输入：命令及其参数、输入/输出重定向操作符。

输出：与真实 Bash 完全一致的输出。

--------------------------- 复杂度 ---------------------------

以下是完成该任务所需时间和工作量的估计数据，
基于至少完成最低分要求的人群统计。

- 代码行数：200-450，平均 350。

- 总耗时：
  * 高级：约 10 小时。
  * 一般：约 15 小时。
  * 吃力：约 20 小时或更多。

- 时间分配：编码与调试大致均衡。实际要写的代码不多，
  但可能需要大量调试。

--------------------------- 运行方法 ---------------------------

任务使用 CMake 编译。可按以下方式使用：

- 进入任务目录，路径为 `<...>/sysprog/2/`。
- 创建 build 目录并进入：
    mkdir build
    cd build
- 配置项目：
    cmake ..
- 编译：
    make
- 运行你的 shell：
    ./mybash

CMake 提供一些选项，每个选项（如 SOME_OPTION）
可用以下语法设置：
    cmake -DSOME_OPTION=value ..

本任务可用选项：

- ENABLE_LEAK_CHECKS：使用 heap_help 工具检查泄漏或堆误用。
  - 0 = 关闭（默认）。
  - 1 = 开启。

- ENABLE_GLOB_SEARCH：构建目录中所有 C/C++ 源文件。
  当你新增文件且不想逐一列出时很有用。
  - 0 = 关闭（默认）。
  - 1 = 开启。

- CMAKE_BUILD_TYPE：
  - Release = 开启优化。更快，但不利于交互式调试。
  - Debug = 关闭优化。更慢，但适合交互式调试。

------------------------- 输入示例 -------------------------

输入示例：

* 打印进程列表并查找其中的 `init` 字符串：

    > ps aux | grep init

* 执行 Python 代码并在输出中查找字符串：

    > echo "print('result is ', 123 + 456)" | python -i | grep result

* 输出包含转义引号的字符串到文件并打印：

    > echo "some text\" with quote" > test.txt
    > cat test.txt

* 追加到文件：

    > echo "first data" > test.txt
    > echo "second" >> test.txt
    > cat test.txt

* 启动交互式 Python 控制台并执行操作：

    > python
    >>> print(1 + 2)
    >>> 3

----------------------- 建议与提示 ------------------------

- 尝试先实现一个简单的 `main.cpp`，只执行一个硬编码命令，
  使用 `fork()` + `exec...()`。

  然后逐步扩展。例如用一条管道连接两个硬编码命令，
  如 `echo abc | grep a`。使用 `fork()` + `exec...()` + `pipe()` + `dup2()`
  让第一个命令的输出成为第二个命令的输入。

  当它能工作后，再尝试增加第三个命令：
  例如 `echo abc | grep a | cat`。你需要 3 次 `fork`、2 条 `pipe`、
  以及若干 `dup2()` 调用。做到这里，你会看到一种模式，
  可用于支持任意数量的管道。

- 在开始写解题代码之前，先熟悉解析器的 API。

- 开始阶段先实现不含 `|`、`>`、`>>` 的单命令执行。

- `tests.txt` 中的测试可以为调试而修改。
  或者复制到交互式终端进行手动调试。
  例如你可以删除后面的测试，只保留最前面的几个，
  然后用 `checker.py` 验证。

- 逐步添加对 `|`、`>`、`>>` 的支持，循序渐进。
  不要试图一次性实现全部功能。真实的生产开发中也是逐步添加功能。

- 可以向 ChatGPT 或其他 AI 询问 Bash、管道、fork、exec 等问题，
  大多数情况下这些聊天机器人能提供帮助。

- 用真实的 `/bin/bash` 测试行为。
  注意你的默认终端可能不是 Bash，尤其是在 Mac 上。
  最好显式运行 `/bin/bash`。

- 如果在支持 `exit` 命令及其退出码时遇到困难，
  可用 `echo $?` 查看 Bash 的退出码，
  然后在你的终端中复现相同行为。

- 在尝试通过测试时，别忘了移除或注释调试输出。
  否则输出将与 Bash 不一致，测试会失败。

- 调试时，你可能会发现 gdb 或 lldb 不太好用，
  因为多进程调试并不友好。你可能需要使用 `printf()`。
  为了简化，可将其封装为宏，如 `#define mylog printf`，
  在正式测试前再用 `#define mylog(...)` 将日志禁用。

  注意子进程中的日志若写到 STDOUT，
  可能看不到，因为 STDOUT 可能被重定向。
  这时可以将日志写到解题目录某个固定路径的文件中，
  所有进程都写它，且不会干扰 STDOUT。

- 请非常小心地正确关闭管道。
  如果你忘记关闭某个管道的读端，写端最终会被阻塞，反之亦然。
  另外请记住：当你 `pipe(int[2])` 后再 `fork()`，父子进程都会各自拥有
  这两个描述符，共 4 个。最好在每个进程中立刻关闭不需要的一端。

- 若出现管道无法打开的奇怪错误，
  可尝试提高文件描述符限制（见 `ulimit -n`），
  也可能是你忘记关闭未使用的管道端。

一种可能的架构如下：有一个“终端进程”读取用户命令。
对每条命令它都会 `fork()`，子进程用 `exec*()` 执行命令，
父进程等待子进程结束。

对每个 `|`，终端创建一条管道，用于连接一个子进程的输入与另一个子进程的输出。

对 `>` 和 `>>`，终端打开文件，并使用 `dup/dup2()` 重定向子进程的标准输出，
使其写入该文件。
